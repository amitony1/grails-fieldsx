The _Fields plugin_ allows you to customize the rendering of input fields for properties of domain objects, command beans and POGOs based on their type, name, etc. The plugin aims to:

* Use good defaults for fields.
* Make it very easy to override the field rendering for particular properties or property types without having to replace entire form templates.
* Not require you to copy and paste markup for containers, labels and error messages just because you need a different input type.
* Support inputs for property paths of arbitrary depth and with indexing.
* Enable other plugins to provide field rendering for special property types that gets picked up automatically (e.g. the _Joda Time_ plugin can provide templates for the various date/time types).
* Support embedded properties of _GORM_ domain classes.

## Tags

### f:input and f:field

`f:input` renders an appropriate input for a property, for example an `<input type="text">` element for a _String_ property or a `<select>` for an enum.

`f:field` renders the input using `f:input` accompanied by any surrounding markup, typically a container, a `label` tag and any validation messages. By default the `f:field` tag will output:

	<div>
		<label for="foo">Foo</label>
		<!-- the input as generated by f:input -->
	</div>

#### Attributes

Both tags share the same exact set of attributes:

* **bean (_required_ if not inside `f:with`)**: The bean whose property is being rendered. This can be the object itself or the name of a page-scope variable.
* **property (_required_)**: The path to the property. This can include any level of nesting and numeric or string indexes. For example `employees[0].address[home].street` is a valid path.
* **value**: Overrides the actual value of the property.
* **default**: A default value for the property that will be used if the actual property value is _falsy_.
* **required**: Overrides the required status of the property. By default this is worked out based on the property's constraints.
* **invalid**: Overrides the validity of the property. By default this is worked out using the bean's _errors_ property for domain and command objects.
* **label**: Overrides the field label passed to the template.
* **labelKey**: Overrides the field label passed to the template using a message from an i18n bundle.

### f:all

Renders fields for all properties of an object by using `f:field` for each property.

The _id_, _version_, _dateCreated_ and _lastUpdated_ properties are skipped on domain classes.

Embedded properties are included with a surrounding _fieldset_. For example if you have a _Person_ class with a _name_ property and an _Address_ embedded class with _street_, _city_ and _country_ properties `<f:all bean="person">` will effectively do this:

	<f:field bean="person" property="name"/>
	<fieldset>
		<legend>Address</legend>
		<f:field bean="person" property="address.street"/>
		<f:field bean="person" property="address.city"/>
		<f:field bean="person" property="address.country"/>
	</fieldset>

#### Attributes

* **bean (_required_ if not inside `f:with`)**: The bean whose property is being rendered. This can be the object itself or the name of a page-scope variable.
* **except**: A comma-separated list of properties that should be skipped (in addition to the defaults).

### f:with

Places a bean in scope so that the bean attribute can be omitted on contained tags. For example:

	<f:with bean="person">
		<f:field property="name"/>
		<f:field property="address.city"/>
	</f:with>

#### Attributes

* **bean (_required_)**: The bean whose property is being rendered. This can be the object itself or the name of a page-scope variable.

## Overriding rendering

The plugin resolves the GSP template used for each property according to conventions. You can override the rendering based on the class and property name or the property type. The `f:field` tag looks for a template called `_field.gsp` and the `f:input` tag looks for a template called `_input.gsp`. Both tags will look in the following locations in decreasing order of preference:

1. `grails-app/views/`_controllerName_`/`_propertyName_`/`
1. `grails-app/views/forms/`_class_`/`_propertyName_`/`
1. `grails-app/views/forms/`_superclass_`/`_propertyName_`/`
1. `grails-app/views/forms/`_propertyType_`/`
1. `grails-app/views/forms/`_propertySuperclass_`/`
1. `grails-app/views/forms/default/`

The variable referenced in these paths are:

* **controllerName**: The name of the current controller (if any).
* **class**: The bean class. For simple properties this is the class of the object passed to the _bean_ attribute of the _f:field_ or _f:input_ tag but when the _property_ attribute was nested this is the class at the end of the chain. For example, if the property path was _employees[0].address.street_ this will be the class of _address_.
* **superclass**: Any superclass of _class_ up to but not including _java.lang.Object_.
* **propertyName**: The property name at the end of the chain passed to the _property_ attribute of the _f:field_ or _f:input_ tag. For example, if the property path was _employees[0].address.street_ then this will be _street_.
* **propertyType**: The type of the property at the end of the chain passed to the _property_ attribute of the _f:field_ or _f:input_ tag. For example, for a _java.lang.String_ property this would be _string_.
* **propertySuperclass**: Any superclass of _propertyType_ up to but not including _java.lang.Object_.

All class names are camel-cased simple forms. For example _java.lang.String_ = _string_, _com.project.HomeAddress_ = _homeAddress_.

Templates are resolved in this order so that you can override in the more specific circumstance and fall back to successively more general defaults. For example, you can define a field template for all _java.lang.String_ properties but override a specific property of a particular class to use more specialized rendering.

Templates in plugins are resolved as well. This means plugins such as _Joda Time_ can provide default rendering for special property types. A template in your application will take precedence over a template in a plugin at the same 'level'. For example if a plugin provides a `grails-app/views/forms/string/_input.gsp` the same template in your application will override it but if the plugin provides `grails-app/views/forms/person/name/_input.gsp` it would be used in preference to the more general template in your application.

For most properties the out-of-the-box defaults should provide a good starting point.

### Example

Imagine an object of class _Employee_ that extends the class _Person_ and has a a String _name_ property.

You can override the template `f:field` uses with any of these:

1. `grails-app/views/forms/`_controllerName_`/name/_field.gsp`
1. `grails-app/views/forms/employee/name/_field.gsp`
1. `grails-app/views/forms/person/name/_field.gsp`
1. `grails-app/views/forms/string/_field.gsp`
1. `grails-app/views/forms/default/_field.gsp`

and override the template `f:input` uses with any of these:

1. `grails-app/views/forms/`_controllerName_`/name/_input.gsp`
1. `grails-app/views/forms/employee/name/_input.gsp`
1. `grails-app/views/forms/person/name/_input.gsp`
1. `grails-app/views/forms/string/_input.gsp`
1. `grails-app/views/forms/default/_input.gsp`

## Scaffolding

Scaffolding templates based on the _Form Fields_ plugin are quite powerful as they will pick up field and input rendering templates from your application and any plugins that provide them. This means that the useful life of scaffolding templates should be much longer as you do not need to replace the entire _create.gsp_ and/or _edit.gsp_ template just because you want to do something different with one particular field.

The plugin makes the _renderEditor.template_ file used by standard Grails scaffolding redundant. This template was very limited in that it could not be extended by plugins (only replaced) and was unable to support embedded properties of domain classes.

The _Form Fields_ plugin includes scaffolding templates you can use in your application by running:

	grails install-form-fields-templates

This will overwrite any _create.gsp_ and _edit.gsp_ files you have in `src/templates/scaffolding`.

Alternatively, it's very easy to modify your existing scaffolding templates to use the `f:all` tag or multiple `f:field` tags.